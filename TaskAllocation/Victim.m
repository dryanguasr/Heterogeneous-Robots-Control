classdef Victim
    properties
        % Características y estado de la víctima
        Pos = [0;0];         % Posición
        Vel = [0;0];         % Velocidad actual
        V0 = 1;              % Velocidad promedio [m/s]
        Sr = 1;              % Radio de Sensado [m]
        Cr = 1;              % Radio de comunicación [m]
        Type = 0;            % Tipo de la víctima (0->movil, 1->inmovil, 2->falsa)
        Saw = 0;             % Bandera que indica si ya ha sido identificada
        ID = 0;              % ID de la victima en la misión
        % Funciónes de potencial de atracción y repulsión
        PotNet = [0;0];
        Robot = 0;
        % Parámetros del Controlador
        Kar = 1;            % Constante proporcional para atracción/repulsión
    end
    methods
    %% Constructor
        function victim = Victim(ID, Type, pos, V0, Sr, Cr, Kar)
            % Propiedades y estado del robot
            victim.ID = ID;
            victim.Type = Type;
            victim.V0 = V0;
            victim.Sr = Sr;
            victim.Cr = Cr;
            victim.Kar = Kar;
            victim.Pos = pos;
        end
    %% Evasión de Obstáculos
    % función de detección de obstáculos
        function victim = detectObstacle(victim,Map,MW,MH,Mres)
            Obs = inf;
            % Detect Obstacle in range
            for i = 1:1:MW/Mres % for each x pos (can be reduced to the
                                    % Sensed area)
                for j = 1:1:MH/Mres % for each y pos (can be reduced to
                                        % Sensed area)                    
                    DObs = sqrt((victim.Pos(1)-i*Mres).^2+(victim.Pos(2)-j*Mres).^2);
                    if(DObs <= Obs && DObs <= victim.Sr && Map(i,j) == 2)
                        Obs = DObs;
                        ObsPos = [i*Mres;j*Mres];
                    end
                end
            end
            % If an obstacle was detected adds 
            % the potential generated by it
            if(Obs ~= inf && Obs > Mres)
                PotNorm = -1/(Obs-Mres)^3;
                direction = (victim.Pos-ObsPos)/norm((victim.Pos-ObsPos));
                victim.PotNet = victim.PotNet + PotNorm*direction;
            end
        end
    %% Funciones de mantenimiento de la comunicación
        function victim = conectToRobot(victim,rn)
            Drv2 = (rn.Pos(1)-victim.Pos(1))^2+(rn.Pos(2)-victim.Pos(2))^2;
            PotNorm = -1/Drv2;
            % PotNorm = 0;
            PotDir = (victim.Pos-rn.Pos)/sqrt(Drv2);
            if (rn.VictimTar == victim.ID)
                PotNorm = sqrt(Drv2)-victim.Cr;
                victim.Robot = rn.ID;
            end
            victim.PotNet = victim.PotNet + PotNorm*PotDir;
        end
        function victim = conectToVictim(victim,vn)
            Dvv2 = (vn.Pos(1)-victim.Pos(1))^2+(vn.Pos(2)-victim.Pos(2))^2;
            if(Dvv2 ~= 0)
                PotNorm = -1/Dvv2;    
            else
                PotNorm = 0;
            end
            victim.PotNet = victim.PotNet + PotNorm*(victim.Pos-vn.Pos)/sqrt(Dvv2);
        end
        function victim = cleanVictimPotential(victim)
            victim.PotNet = [0;0];
        end
    %% Señal de control
        % determinación de la señal de control
        function [victim,u] = controlSignal(victim)
            u = - victim.Kar*victim.PotNet;
            uNorm = norm(u);
            % saturates the victim input
            if(uNorm > victim.V0)
                u = victim.V0 * u/uNorm;
            end
            victim.Vel = u;
            if(victim.Type ~= 0)
                u = 0;
            end
        end
    % Dinámica de Movimiento
        % Dinámica de Movimiento según entrada
        function victim = move(victim, u, dt)
            newPos = victim.Pos + u .* dt;
            victim.Pos = newPos;
        end
    end
end